import { ref, reactive } from 'vue'
import { useDebounceFn } from '@vueuse/core'

export interface ValidationRule {
  columnName: string
  ruleType: 'Required' | 'Regex' | 'Range' | 'Custom'
  errorMessage: string
  regexPattern?: string
  minValue?: any
  maxValue?: any
  severity: 'Info' | 'Warning' | 'Error' | 'Critical'
  customValidator?: (value: any) => boolean
}

export interface ValidationError {
  rowId: string
  columnName: string
  message: string
  severity: string
}

export interface ValidationResult {
  isValid: boolean
  error?: string
  severity?: string
}

export function useValidation() {
  // Each instance has its own validation state
  const validationRules = ref<Map<string, ValidationRule[]>>(new Map())
  // Use reactive object instead of ref<Map> for proper Vue reactivity
  const validationErrors = reactive<Record<string, ValidationError[]>>({})

  function addValidationRule(rule: ValidationRule) {
    const rules = validationRules.value.get(rule.columnName) || []
    rules.push(rule)
    validationRules.value.set(rule.columnName, rules)

    console.log('[useValidation] addValidationRule:', {
      columnName: rule.columnName,
      ruleType: rule.ruleType,
      severity: rule.severity,
      totalRulesForColumn: rules.length
    })
  }

  function validateCell(rowId: string, columnName: string, value: any): ValidationResult {
    const rules = validationRules.value.get(columnName) || []

    console.log('[useValidation] validateCell:', {
      rowId,
      columnName,
      value,
      ruleCount: rules.length,
      isEmpty: value == null || value === ''
    })

    // Check if value is empty
    const isEmpty = value == null || value === ''

    for (const rule of rules) {
      // Required validation
      if (rule.ruleType === 'Required') {
        if (isEmpty) {
          console.log('[useValidation] validateCell FAILED: Required', {
            rowId,
            columnName,
            error: rule.errorMessage,
            severity: rule.severity
          })
          return {
            isValid: false,
            error: rule.errorMessage,
            severity: rule.severity
          }
        }
      }

      // Skip other validations if value is empty (only validate non-empty values)
      if (isEmpty) continue

      // Regex validation
      if (rule.ruleType === 'Regex' && rule.regexPattern) {
        const regex = new RegExp(rule.regexPattern)
        if (!regex.test(String(value))) {
          console.log('[useValidation] validateCell FAILED: Regex', {
            rowId,
            columnName,
            value,
            pattern: rule.regexPattern,
            error: rule.errorMessage
          })
          return {
            isValid: false,
            error: rule.errorMessage,
            severity: rule.severity
          }
        }
      }

      // Range validation
      if (rule.ruleType === 'Range') {
        const numValue = Number(value)
        if (isNaN(numValue)) {
          console.log('[useValidation] validateCell FAILED: Range (not a number)', {
            rowId,
            columnName,
            value
          })
          return {
            isValid: false,
            error: 'Value must be a number',
            severity: rule.severity
          }
        }

        if (rule.minValue != null && numValue < rule.minValue) {
          console.log('[useValidation] validateCell FAILED: Range (below min)', {
            rowId,
            columnName,
            value: numValue,
            minValue: rule.minValue
          })
          return {
            isValid: false,
            error: rule.errorMessage,
            severity: rule.severity
          }
        }

        if (rule.maxValue != null && numValue > rule.maxValue) {
          console.log('[useValidation] validateCell FAILED: Range (above max)', {
            rowId,
            columnName,
            value: numValue,
            maxValue: rule.maxValue
          })
          return {
            isValid: false,
            error: rule.errorMessage,
            severity: rule.severity
          }
        }
      }

      // Custom validation
      if (rule.ruleType === 'Custom' && rule.customValidator) {
        if (!rule.customValidator(value)) {
          console.log('[useValidation] validateCell FAILED: Custom', {
            rowId,
            columnName,
            value,
            error: rule.errorMessage
          })
          return {
            isValid: false,
            error: rule.errorMessage,
            severity: rule.severity
          }
        }
      }
    }

    console.log('[useValidation] validateCell PASSED', {
      rowId,
      columnName,
      value
    })
    return { isValid: true }
  }

  // Helper: Check if entire row is empty (all data columns have no value)
  function isRowCompletelyEmpty(rowCells: Array<{ columnName: string; value: any }>): boolean {
    return rowCells.every(cell => cell.value == null || cell.value === '')
  }

  // Throttled validation (300ms) with row-empty check
  const validateCellThrottled = useDebounceFn(
    (rowId: string, columnName: string, value: any, rowCells?: Array<{ columnName: string; value: any }>) => {
      console.log('[useValidation] validateCellThrottled:', {
        rowId,
        columnName,
        value,
        hasRowCells: !!rowCells,
        rowCellsCount: rowCells?.length
      })

      // If row cells provided, check if entire row is empty
      if (rowCells && isRowCompletelyEmpty(rowCells)) {
        console.log('[useValidation] validateCellThrottled: Row is completely empty, clearing errors', {
          rowId
        })
        // Entire row is empty - clear ALL validation errors for this row
        delete validationErrors[rowId]
        return
      }

      const result = validateCell(rowId, columnName, value)

      // Update errors map
      const rowErrors = validationErrors[rowId] || []

      if (!result.isValid) {
        // Add/update error
        const existingErrorIdx = rowErrors.findIndex(e => e.columnName === columnName)
        const error: ValidationError = {
          rowId,
          columnName,
          message: result.error!,
          severity: result.severity!
        }

        if (existingErrorIdx >= 0) {
          rowErrors[existingErrorIdx] = error
          console.log('[useValidation] validateCellThrottled: Updated existing error', {
            rowId,
            columnName,
            error: error.message
          })
        } else {
          rowErrors.push(error)
          console.log('[useValidation] validateCellThrottled: Added new error', {
            rowId,
            columnName,
            error: error.message
          })
        }

        validationErrors[rowId] = rowErrors
      } else {
        // Clear error for this column
        const filteredErrors = rowErrors.filter(e => e.columnName !== columnName)
        if (filteredErrors.length > 0) {
          validationErrors[rowId] = filteredErrors
          console.log('[useValidation] validateCellThrottled: Cleared error for column, other errors remain', {
            rowId,
            columnName,
            remainingErrors: filteredErrors.length
          })
        } else {
          delete validationErrors[rowId]
          console.log('[useValidation] validateCellThrottled: Cleared all errors for row', {
            rowId
          })
        }
      }
    },
    300
  )

  async function validateAll(rows: any[]) {
    console.log('[useValidation] validateAll:', {
      rowCount: rows.length,
      totalCells: rows.reduce((sum, row) => sum + row.cells.length, 0)
    })

    // Clear all errors
    Object.keys(validationErrors).forEach(key => delete validationErrors[key])
    let totalErrors = 0

    for (const row of rows) {
      // DEBUG: Log first 3 rows to see what data we have
      const rowIndex = rows.indexOf(row)
      if (rowIndex < 3) {
        console.log('[useValidation] validateAll: Examining row', {
          rowId: row.rowId,
          rowIndex,
          cellCount: row.cells?.length || 0,
          cellsPreview: row.cells?.slice(0, 3).map((c: any) => ({
            columnName: c.columnName,
            value: c.value,
            valueType: typeof c.value,
            isEmpty: c.value == null || c.value === ''
          }))
        })
      }

      // Skip empty rows - only validate rows with at least one non-empty cell
      if (isRowCompletelyEmpty(row.cells)) {
        console.log('[useValidation] validateAll: Skipping empty row', {
          rowId: row.rowId,
          cellCount: row.cells?.length || 0
        })
        continue
      }

      for (const cell of row.cells) {
        const result = validateCell(row.rowId, cell.columnName, cell.value)
        if (!result.isValid) {
          const rowErrors = validationErrors[row.rowId] || []
          rowErrors.push({
            rowId: row.rowId,
            columnName: cell.columnName,
            message: result.error!,
            severity: result.severity!
          })
          validationErrors[row.rowId] = rowErrors
          totalErrors++
        }
      }
    }

    console.log('[useValidation] validateAll complete:', {
      isValid: totalErrors === 0,
      totalErrors,
      rowsWithErrors: Object.keys(validationErrors).length,
      validationErrorsKeys: Object.keys(validationErrors),
      validationErrorsPreview: Object.entries(validationErrors).slice(0, 2).map(([rowId, errors]) => ({
        rowId,
        errorCount: errors.length,
        errors: errors.map(e => `${e.columnName}: ${e.message}`)
      }))
    })

    return {
      isValid: totalErrors === 0,
      totalErrors,
      errors: Object.values(validationErrors).flat()
    }
  }

  function getValidationErrors(rowId: string): ValidationError[] {
    return validationErrors[rowId] || []
  }

  function clearValidationErrors() {
    const clearedCount = Object.keys(validationErrors).length
    console.log('[useValidation] clearValidationErrors:', {
      clearedCount
    })
    Object.keys(validationErrors).forEach(key => delete validationErrors[key])
  }

  return {
    validationRules,
    validationErrors,
    addValidationRule,
    validateCell,
    validateCellThrottled,
    validateAll,
    getValidationErrors,
    clearValidationErrors
  }
}
